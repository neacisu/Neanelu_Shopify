#!/usr/bin/env -S npx tsx
/**
 * Schema Test Generator
 *
 * Parses Database_Schema_Complete.md and generates test files
 * for schema verification.
 *
 * Usage: npx tsx packages/database/scripts/generate-schema-tests.ts
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const DOCS_PATH = path.resolve(__dirname, '../../../Docs/Database_Schema_Complete.md');
const OUTPUT_DIR = path.resolve(__dirname, '../src/__tests__/generated');

interface TableInfo {
  name: string;
  module: string;
  columns: string[];
  hasRls: boolean;
  isPartitioned: boolean;
}

interface ParsedSchema {
  tables: TableInfo[];
  indexes: string[];
  constraints: string[];
}

/**
 * Parse the Database_Schema_Complete.md file
 */
function parseSchemaDoc(content: string): ParsedSchema {
  const tables: TableInfo[] = [];
  const indexes: string[] = [];
  const constraints: string[] = [];

  // Simple parsing - extract table names from markdown
  const tableMatches = content.matchAll(/### (\w+)/g);
  for (const match of tableMatches) {
    const name = match[1];
    if (name && !name.startsWith('Module') && !name.startsWith('Index')) {
      tables.push({
        name,
        module: 'unknown',
        columns: [],
        hasRls: false,
        isPartitioned: false,
      });
    }
  }

  // Extract index names
  const indexMatches = content.matchAll(/idx_\w+/g);
  for (const match of indexMatches) {
    if (!indexes.includes(match[0])) {
      indexes.push(match[0]);
    }
  }

  // Extract constraint names
  const constraintMatches = content.matchAll(/chk_\w+|fk_\w+|uq_\w+/g);
  for (const match of constraintMatches) {
    if (!constraints.includes(match[0])) {
      constraints.push(match[0]);
    }
  }

  return { tables, indexes, constraints };
}

/**
 * Generate test file content for a module
 */
function generateModuleTest(moduleName: string, tables: TableInfo[]): string {
  const testCases = tables
    .map(
      (table) => `
  void it('${table.name} table exists', async () => {
    const info = await getTableInfo('${table.name}');
    assert.ok(info, '${table.name} should exist');
  });`
    )
    .join('\n');

  return `/**
 * Auto-generated Schema Tests for ${moduleName}
 * Generated by: generate-schema-tests.ts
 * DO NOT EDIT MANUALLY
 */

import { describe, it, before, after } from 'node:test';
import assert from 'node:assert';
import { getPool, closePool, shouldSkipDbTests } from '../helpers/test-utils.ts';
import { getTableInfo } from '../helpers/schema-queries.ts';

const SKIP = shouldSkipDbTests();

void describe('Generated: ${moduleName}', { skip: SKIP }, () => {
  before(() => {
    getPool();
  });

  after(async () => {
    await closePool();
  });
${testCases}
});
`;
}

/**
 * Main function
 */
function main(): void {
  console.info('ðŸ” Parsing Database_Schema_Complete.md...');

  // Check if docs file exists
  if (!fs.existsSync(DOCS_PATH)) {
    console.error(`âŒ File not found: ${DOCS_PATH}`);
    console.info('ðŸ“ Creating placeholder tests instead...');

    // Create output directory
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Create a basic placeholder test
    const placeholderContent = `/**
 * Generated Schema Tests Placeholder
 *
 * This file is auto-generated. Run the generator when
 * Database_Schema_Complete.md is available.
 */

import { describe, it } from 'node:test';
import assert from 'node:assert';

void describe('Generated Tests Placeholder', () => {
  void it('placeholder test', () => {
    assert.ok(true, 'Placeholder test passes');
  });
});
`;

    fs.writeFileSync(path.join(OUTPUT_DIR, 'placeholder.test.ts'), placeholderContent);

    console.info('âœ… Created placeholder test');
    return;
  }

  // Parse the schema document
  const content = fs.readFileSync(DOCS_PATH, 'utf-8');
  const schema = parseSchemaDoc(content);

  console.info(`ðŸ“Š Found ${schema.tables.length} tables`);
  console.info(`ðŸ“Š Found ${schema.indexes.length} indexes`);
  console.info(`ðŸ“Š Found ${schema.constraints.length} constraints`);

  // Create output directory
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Generate test file
  const testContent = generateModuleTest('All Tables', schema.tables);
  const outputPath = path.join(OUTPUT_DIR, 'schema-from-docs.test.ts');

  fs.writeFileSync(outputPath, testContent);
  console.info(`âœ… Generated: ${outputPath}`);

  console.info('\nðŸŽ‰ Schema test generation complete!');
}

try {
  main();
} catch (error) {
  console.error(error);
  process.exit(1);
}
